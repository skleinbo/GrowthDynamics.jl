<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dynamics · GrowthDynamics.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">GrowthDynamics.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Overview</a></li><li><span class="tocitem">States</span><ul><li><a class="tocitem" href="states.html">Populations</a></li><li><a class="tocitem" href="lattices.html">Lattices</a></li><li><a class="tocitem" href="metadata.html">Metadata</a></li><li><a class="tocitem" href="phylogenies.html">Phylogenies</a></li></ul></li><li class="is-active"><a class="tocitem" href="dynamics.html">Dynamics</a><ul class="internal"><li><a class="tocitem" href="#Available-dynamics"><span>Available dynamics</span></a></li><li><a class="tocitem" href="#Spatial"><span>Spatial</span></a></li><li><a class="tocitem" href="#Non-spatial"><span>Non-spatial</span></a></li><li><a class="tocitem" href="#Adding-your-own"><span>Adding your own</span></a></li></ul></li><li><a class="tocitem" href="observables.html">Observables</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="dynamics.html">Dynamics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="dynamics.html">Dynamics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/skleinbo/GrowthDynamics.jl/blob/master/docs/src/dynamics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Evolving-populations"><a class="docs-heading-anchor" href="#Evolving-populations">Evolving populations</a><a id="Evolving-populations-1"></a><a class="docs-heading-anchor-permalink" href="#Evolving-populations" title="Permalink"></a></h1><p>Routines to advance a population state for a number of time steps, or until a pre-specified condition is met.</p><h2 id="Available-dynamics"><a class="docs-heading-anchor" href="#Available-dynamics">Available dynamics</a><a id="Available-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Available-dynamics" title="Permalink"></a></h2><p>All routines take a <code>Population</code> as their first and only positional argument, and further parameters like mutation rate as keyword arguments.</p><h2 id="Spatial"><a class="docs-heading-anchor" href="#Spatial">Spatial</a><a id="Spatial-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial" title="Permalink"></a></h2><h3 id="An-Eden-like-model"><a class="docs-heading-anchor" href="#An-Eden-like-model">An Eden-like model</a><a id="An-Eden-like-model-1"></a><a class="docs-heading-anchor-permalink" href="#An-Eden-like-model" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GrowthDynamics.LatticeDynamics.eden_with_density!" href="#GrowthDynamics.LatticeDynamics.eden_with_density!"><code>GrowthDynamics.LatticeDynamics.eden_with_density!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eden_with_density!(state::Population)</code></pre><p>Cells proliferate to neighboring lattice sites with a rate proportional to the number of  free neighboring sites. A time step is either a birth, death, or mutation-only event.</p><p>A custom <code>label</code> function must be provided if genotypes are not integers.</p><p>See the &#39;extended help&#39; for signatures of the various callbacks.</p><p><strong>Keyword arguments</strong></p><ul><li><code>T::Int</code>: number of steps to advance.</li><li><code>d=0.0</code>: death rate. Zero halts the dynamics after carrying capacity is reached.</li><li><code>fitness=(population, old_genotype, new_genotype)-&gt;1.0</code>: function that assigns a fitness value (default <code>1.0</code>) to a new genotype. </li><li><code>mu=0.0</code>: mutation rate; either a function or number.</li><li><code>label=(population, old_genotype) -&gt; lastgenotype(population)+1</code>: function that assigns the new genotype upon mutation. </li><li><code>makesnps=true</code>: generate SNPs during the simulation?</li><li><code>mu_type=[:poisson, :fixed]</code>: number of mutations is fixed, or Poisson distributed.</li><li><code>genome_length=10^9</code>: length of the genome.</li><li><code>baserate=1.0</code>: progressing real time is measured in <code>1/baserate</code>.</li><li><code>prune_period=0</code>: prune the phylogeny periodically after no. of steps, set to <code>0</code> to disable.</li><li><code>prune_on_exit=true</code>: prune before leaving the simulation.</li><li><code>onstep</code>: callback that is executed at the very beginning of every time step.</li><li><code>onprebirth</code>: callback that runs if a birth event is about to occur. Return value determines whether cell actually proliferates.</li><li><code>onpostbirth</code>: callback that runs at the very end of a proliferation event.</li><li><code>ondeath</code>: callback that runs at the very end of a death event.</li></ul><p><strong>Extended help</strong></p><p><strong>Mutations</strong></p><p>The rate of mutations is steered by the keyword argument <code>mu</code>, which is either a number or a function.</p><p>A number is automatically converted to an appropriate function. As a function it must have signature <code>mu(population, old_genotype, I_old, I_new)-&gt;(rate, p_mutate)::Tuple{Float64, Float64}</code> where</p><ul><li><code>old_genotype</code> is the genotype of the parent cell</li><li><code>I_old</code>, <code>I_new</code> are the <em>linear</em> lattice indices of the parent and daughter cell.</li></ul><p>This way the mutation rate can depend on position as well as on mutations present in the parental genome.</p><p>The output must be a tuple, where the first entry <code>rate</code> determines the number of mutations <strong>if</strong> mutations happen; the probability of which is given by the second entry <code>p_mutate</code>. The main reason for keeping these quantities separate is that one will often not generate SNPs during the simulation, because that process is rather costly, but generate them later on the basis of the final phylogeny.</p><p>If <code>mu</code> is a number, it is implicitely wrapped in a function that returns <code>(mu, 1-exp(-mu))</code>, i.e. the mutation probability is the probability of at least one event under a Poisson distribution with rate <code>mu</code>.</p><p>Setting <code>makesnps</code> to <code>true/false</code> determines whether SNPs are generated during the simulation. If it is set to <code>false</code>, the first value returned by <code>mu</code> is inconsequential.</p><p>Finally, <code>label(population, old_genotype)-&gt;new_genotype</code> assigns the designation to a newly entering genotype. It defaults to numbering genotypes consecutively. See also <a href="metadata.html#DataFrames.rename!"><code>rename!</code></a>.</p><p><strong>Fitness</strong></p><p>When a new genotype enters due to a mutation event, it is assigned a fitness value given by a user-provides function <code>(population, old_genotype, new_genotype)-&gt;Float64</code> passed as keyword argument <code>fitness</code>. For example, to inherit the fitness, one would provide  <code>fitness=(p,og,ng)-&gt;p.meta[g=og; :fitness]</code>.</p><p><strong>Callbacks</strong></p><p>Callbacks are triggered at certain stages of the simulation loop:</p><ul><li><code>onstep(population)::Bool</code> is executed at the beginning of each time step. If <code>true</code> is returned, the simulation ends.</li><li><code>onprebirth(population, Iold)::Bool</code> is executed when a birth event is triggered, but <em>before</em> it is executed. If <code>false</code> is returned, the cell  will not proliferate, but might still mutate.</li><li><code>onpostbirth(population, Iold, Inew)</code> is executed after proliferation and mutation are completed. Useful for collecting observables.</li><li><code>ondeath(population, Idead)</code> is executed when a death event has finished.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skleinbo/GrowthDynamics.jl/blob/5c8c22bb9fefe236110d02a975a74c41cb17f88b/src/latticedynamics/edenwithdensity.jl#L1-L71">source</a></section></article><h2 id="Non-spatial"><a class="docs-heading-anchor" href="#Non-spatial">Non-spatial</a><a id="Non-spatial-1"></a><a class="docs-heading-anchor-permalink" href="#Non-spatial" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GrowthDynamics.LatticeDynamics.moran!" href="#GrowthDynamics.LatticeDynamics.moran!"><code>GrowthDynamics.LatticeDynamics.moran!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moran!(state::NoLattice{Int}; &lt;keyword arguments&gt;)</code></pre><p>(Generalized) Moran dynamics on an unstructured population. Birth and death events are independent until the carrying capacity (keyword argument <code>K</code>) is reached.  After that individuals begin replacing each other like in the classic Moran model.</p><p><strong>Arguments</strong></p><ul><li><code>T::Int</code>: the number of steps to advance.</li><li><code>d=0.0</code>: death rate.</li><li><code>K=0</code>: Carrying capacity. Set to <code>0</code> for unlimited.</li><li><code>fitness=(population, old_genotype, new_genotype)-&gt;1.0</code>: function that assigns a fitness value (default <code>1.0</code>) to a new genotype. </li><li><code>mu=0.0</code>: mutation rate; either a function or number.</li><li><code>label=(population, old_genotype) -&gt; lastgenotype(population)+1</code>: function that assigns the new genotype upon mutation. </li><li><code>makesnps=true</code>: generate SNPs during the simulation?</li><li><code>mu_type=[:poisson, :fixed]</code>: number of mutations is fixed, or Poisson distributed.</li><li><code>genome_length=10^9</code>: length of the genome.</li><li><code>baserate=1.0</code>: progressing real time is measured in <code>1/baserate</code>.</li><li><code>prune_period=0</code>: prune the phylogeny periodically after no. of steps, set to <code>0</code> to disable.</li><li><code>prune_on_exit=true</code>: prune before leaving the simulation.</li><li><code>onstep</code>: callback that is executed at the very beginning of every time step.</li><li><code>onprebirth</code>: callback that runs if a birth event is about to occur. Return value determines whether cell actually proliferates.</li><li><code>onpostbirth</code>: callback that runs at the very end of a proliferation event.</li><li><code>ondeath</code>: callback that runs at the very end of a death event.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skleinbo/GrowthDynamics.jl/blob/5c8c22bb9fefe236110d02a975a74c41cb17f88b/src/latticedynamics/moran.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GrowthDynamics.LatticeDynamics.exponential!" href="#GrowthDynamics.LatticeDynamics.exponential!"><code>GrowthDynamics.LatticeDynamics.exponential!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exponential!(state::NoLattice{Int}; &lt;keyword arguments&gt;)</code></pre><p>Run exponential growth on an unstructered population until carrying capacity is reached. No death. </p><p>Each generation consists of the following actions for every genotype:</p><ol><li>The number of decendents is drawn from a binomial distribution with parameters <code>n</code>, the  population number of that genotype, and <code>p</code> given by <code>1-exp(-f/&lt;f&gt;)</code> with fitness value <code>f</code>. That number as capped so as not to exceed the defined carrying capacity.</li><li>Of those decendents the number of mutants is drawn from a binomial distribution according to the mutation rate <code>mu</code>.</li></ol><p><strong>Arguments</strong></p><ul><li><code>T::Int</code>: number of steps to advance.</li><li><code>fitness=(population, old_genotype, new_genotype)-&gt;1.0</code>: function that assigns a fitness value (default <code>1.0</code>) to a new genotype. </li><li><code>mu=0.0</code>: mutation rate; either a function or number.</li><li><code>label=(population, old_genotype) -&gt; lastgenotype(population)+1</code>: function that assigns the new genotype upon mutation. </li><li><code>makesnps=true</code>: generate SNPs during the simulation?</li><li><code>mu_type=[:poisson, :fixed]</code>: number of mutations is fixed, or Poisson distributed.</li><li><code>genome_length=10^9</code>: length of the genome.</li><li><code>baserate=1.0</code>: progressing real time is measured in <code>1/baserate</code>.</li><li><code>prune_period=0</code>: prune the phylogeny periodically after no. of steps, set to <code>0</code> to disable.</li><li><code>prune_on_exit=true</code>: prune before leaving the simulation.</li><li><code>onstep</code>: callback that is executed at the very beginning of every time step.</li><li><code>ondeath</code>: callback that runs at the very end of a death event.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/skleinbo/GrowthDynamics.jl/blob/5c8c22bb9fefe236110d02a975a74c41cb17f88b/src/latticedynamics/exponential.jl#L1-L28">source</a></section></article><h2 id="Adding-your-own"><a class="docs-heading-anchor" href="#Adding-your-own">Adding your own</a><a id="Adding-your-own-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-your-own" title="Permalink"></a></h2><p>There is no particular interface or signature an evolution routine must adhere to.</p><p>However, to avoid putting the lattice, metadata and phylogeny in an inconsistent state, a few tips should be followed</p><ul><li>Use the getter and setter methods for <a href="metadata.html#GrowthDynamics.Populations.MetaData"><code>MetaData</code></a> instead of manipulating the fields directly.</li><li>Using <code>metadata[g=genotype; Val(:field)]</code> is more performant than <code>metadata[g=genotype; :field]</code> if <code>:field</code> is constant, because   the former avoids dynamic dispatch.</li><li>Use <code>population[index] (= genotype)</code> to get/set the genotype of a cell at a position.   Do not manipulate <code>population.lattice.data</code> directly.</li><li>Prefer <a href="states.html#GrowthDynamics.Populations.add_genotype!"><code>add_genotype!</code></a> over <a href="states.html#Base.push!"><code>push!</code></a>.</li><li>Use <a href="states.html#GrowthDynamics.Populations.remove_genotype!"><code>remove_genotype!</code></a>.</li><li>For performance reasons SNPs are either <code>Vector{Int}</code> or <code>nothing</code>. Check for the latter with <a href="metadata.html#GrowthDynamics.Populations.hassnps"><code>hassnps</code></a> before  adding new ones.</li><li>Not a must, but don&#39;t forget to advance the step/real time counters <code>population.t</code> and <code>population.treal</code> after each simulation step.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="phylogenies.html">« Phylogenies</a><a class="docs-footer-nextpage" href="observables.html">Observables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 9 August 2023 07:47">Wednesday 9 August 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
