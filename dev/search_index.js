var documenterSearchIndex = {"docs":
[{"location":"lattices.html#lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Each cell occupies a site on a lattice. A lattice provides a mapping between coordinates and indices of the underlying array.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"N.B.: The structures are not true lattices, because they do not extend to infinity, but have finite size.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Currently, the following lattices are provided","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"LineLattice\nHexagonalLattice\nCubicLattice\nFCCLattice","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"They are subtypes of RealLattice. Populations without spatial structure \"live\" on a NoLattice.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"warning: Warning\nAvoid manipulating the data field of a lattice directly. Doing so easily leads to an inconsistent state between lattice and metadata.Use the getter and setter methods for Population instead.","category":"page"},{"location":"lattices.html#Lattice-Types","page":"Lattices","title":"Lattice Types","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"    CubicLattice\n    FCCLattice\n    HexagonalLattice\n    LineLattice\n    NoLattice","category":"page"},{"location":"lattices.html#GrowthDynamics.Lattices.CubicLattice","page":"Lattices","title":"GrowthDynamics.Lattices.CubicLattice","text":"CubicLattice\n\nThree dimensional primitive cubic lattice. Each site has six equidistant neighbors with a fourfold rotational symmetry in each of the three planes.\n\nSee https://en.wikipedia.org/wiki/Cubic_crystal_system\n\nFields\n\na: lattice constant\ndata: underlying array\n\nExample\n\njulia> using GrowthDynamics.Lattices\n\njulia> l = CubicLattice(1/2, ones(16,16,16))\nCubicLattice{Float64, Array{Float64, 3}}(0.5, [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; … ;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0])\n\njulia> neighbors(l, (8,8,8))\n6-element StaticArraysCore.MVector{6, CartesianIndex{3}} with indices SOneTo(6):\n CartesianIndex(7, 8, 8)\n CartesianIndex(9, 8, 8)\n CartesianIndex(8, 7, 8)\n CartesianIndex(8, 9, 8)\n CartesianIndex(8, 8, 7)\n CartesianIndex(8, 8, 9)\n\njulia> coord.(Ref(l), ans)\n6-element StaticArraysCore.MVector{6, GeometryBasics.Point{3, Float32}} with indices SOneTo(6):\n [3.0, 3.5, 3.5]\n [4.0, 3.5, 3.5]\n [3.5, 3.0, 3.5]\n [3.5, 4.0, 3.5]\n [3.5, 3.5, 3.0]\n [3.5, 3.5, 4.0]\n\n\n\n\n\n","category":"type"},{"location":"lattices.html#GrowthDynamics.Lattices.FCCLattice","page":"Lattices","title":"GrowthDynamics.Lattices.FCCLattice","text":"FCCLattice\n\nThree dimensional face-centered cubic lattice. Each site has twelve neighbors.\n\nSee https://en.wikipedia.org/wiki/Cubic_crystal_system\n\nFields\n\na: lattice constant\ndata: underlying array\n\nExample\n\njulia> using GrowthDynamics.Lattices\n\njulia> l = FCCLattice(1/2, ones(16,16,16))\nFCCLattice{Float64, Array{Float64, 3}}(0.5, [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; … ;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0])\n\njulia> neighbors(l, (8,8,8))\n12-element StaticArraysCore.MVector{12, CartesianIndex{3}} with indices SOneTo(12):\n CartesianIndex(7, 8, 8)\n CartesianIndex(9, 8, 8)\n CartesianIndex(9, 7, 8)\n CartesianIndex(7, 7, 8)\n CartesianIndex(7, 8, 9)\n CartesianIndex(8, 7, 9)\n CartesianIndex(9, 8, 9)\n CartesianIndex(8, 8, 9)\n CartesianIndex(7, 8, 7)\n CartesianIndex(8, 7, 7)\n CartesianIndex(9, 8, 7)\n CartesianIndex(8, 8, 7)\n\njulia> coord.(Ref(l), ans)\n12-element StaticArraysCore.MVector{12, GeometryBasics.Point{3, Float32}} with indices SOneTo(12):\n [1.5, 3.75, 1.75]\n [2.0, 3.75, 1.75]\n [2.0, 3.25, 1.75]\n [1.5, 3.25, 1.75]\n [1.5, 3.5, 2.0]\n [1.75, 3.25, 2.0]\n [2.0, 3.5, 2.0]\n [1.75, 3.75, 2.0]\n [1.5, 3.5, 1.5]\n [1.75, 3.25, 1.5]\n [2.0, 3.5, 1.5]\n [1.75, 3.75, 1.5]\n\n\n\n\n\n","category":"type"},{"location":"lattices.html#GrowthDynamics.Lattices.HexagonalLattice","page":"Lattices","title":"GrowthDynamics.Lattices.HexagonalLattice","text":"HexagonalLattice\n\nEach site has six equidistant neighbors with a sixfold rotational symmetry.\n\nSee https://en.wikipedia.org/wiki/Hexagonal_lattice\n\nFields\n\na: lattice constant\ndata: underlying array\n\nExample\n\njulia> using GrowthDynamics.Lattices\n\njulia> l = HexagonalLattice(1/2, ones(32,32))\nHexagonalLattice{Float64, Matrix{Float64}}(0.5, [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0])\n\njulia> neighbors(l, (16,16))\n6-element StaticArraysCore.MVector{6, CartesianIndex{2}} with indices SOneTo(6):\n CartesianIndex(15, 16)\n CartesianIndex(15, 17)\n CartesianIndex(16, 17)\n CartesianIndex(17, 17)\n CartesianIndex(17, 16)\n CartesianIndex(16, 15)\n\njulia> coord.(Ref(l), ans)\n6-element StaticArraysCore.MVector{6, GeometryBasics.Point{2, Float32}} with indices SOneTo(6):\n [7.5, 6.0621777]\n [8.0, 6.0621777]\n [8.25, 6.4951906]\n [8.0, 6.928203]\n [7.5, 6.928203]\n [7.25, 6.4951906]\n\n\n\n\n\n","category":"type"},{"location":"lattices.html#GrowthDynamics.Lattices.LineLattice","page":"Lattices","title":"GrowthDynamics.Lattices.LineLattice","text":"LineLattice\n\nOne dimensional lattice.\n\nFields\n\na: lattice spacing\ndata\n\n\n\n\n\n","category":"type"},{"location":"lattices.html#GrowthDynamics.Lattices.NoLattice","page":"Lattices","title":"GrowthDynamics.Lattices.NoLattice","text":"NoLattice{T}\n\nDummy 'lattice' for systems without spatial structure.\"\n\n\n\n\n\n","category":"type"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Each lattice type except NoLattice derives from RealLattice and implements the following methods","category":"page"},{"location":"lattices.html#Common-Methods","page":"Lattices","title":"Common Methods","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"    coord\n    index\n    coordination\n    dimension\n    midpoint\n    midpointcoord\n    neighbors\n    neighbors!\n    nneighbors\n    density","category":"page"},{"location":"lattices.html#GrowthDynamics.Lattices.coord","page":"Lattices","title":"GrowthDynamics.Lattices.coord","text":"coord(L, I)\n\nCoordinate of index I on the lattice L. I is either a tuple of integers, or an appropriate CartesianIndex.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#Dictionaries.index","page":"Lattices","title":"Dictionaries.index","text":"index(L, p)\n\nIndex of the coordinate p closest to the nearest site on lattice L. p is a GeometryBasics.Point.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.coordination","page":"Lattices","title":"GrowthDynamics.Lattices.coordination","text":"Coordination number of the lattice.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.dimension","page":"Lattices","title":"GrowthDynamics.Lattices.dimension","text":"Dimension of the lattice. Functionally equivalent to ndims(lattice.data).\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.midpoint","page":"Lattices","title":"GrowthDynamics.Lattices.midpoint","text":"midpoint(L)\n\nReturn the index of the point nearest to the geometeric center of the lattice L.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.midpointcoord","page":"Lattices","title":"GrowthDynamics.Lattices.midpointcoord","text":"midpointcoord(L)\n\nReturn the coordinate of the point nearest to the geometeric center of the lattice L.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.neighbors","page":"Lattices","title":"GrowthDynamics.Lattices.neighbors","text":"neighbors(L::RealLattice, I)\n\nVector of neighbors of index I. ReturnsVector{CartesianIndex{dimension(L)}}``.\n\nDoes not check for bounds.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.neighbors!","page":"Lattices","title":"GrowthDynamics.Lattices.neighbors!","text":"neighbors!(n, L, I)\n\nIn-place version of neighbors.\n\nUse n = Neighbors(L) to allocate an appropriate vector.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.nneighbors","page":"Lattices","title":"GrowthDynamics.Lattices.nneighbors","text":"nneighbors(L, I)\n\nBoundary-aware number of nearest neighbors of site I on lattice L. \n\nExample\n\njulia> using GrowthDynamics.Lattices\n\njulia> l = HexagonalLattice(1/2, ones(32,32))\nHexagonalLattice{Float64, Matrix{Float64}}(0.5, [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0])\n\njulia> nneighbors(l, (5,5))\n6\n\njulia> nneighbors(l, (1,5))\n4\n\njulia> nneighbors(l, (1,1))\n2\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.density","page":"Lattices","title":"GrowthDynamics.Lattices.density","text":"density(L::RealLattice{T}, I)\n\nCalculates (occupied sites)/(no. of neighbors)\n\n\"Occupied\" is defined as not equal to zero(T).\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#Radial-geometries","page":"Lattices","title":"Radial geometries","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Populations often grow with approximate radial symmetry. One might then be interested in for example grouping cells with respect to their distance from an origin.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"    shell\n    isonshell\n    conicsection","category":"page"},{"location":"lattices.html#GrowthDynamics.Lattices.shell","page":"Lattices","title":"GrowthDynamics.Lattices.shell","text":"shell(L::CubicLattice, r, o=midpointcoord(L))\n\nReturn indices of shell of radius r around o.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.isonshell","page":"Lattices","title":"GrowthDynamics.Lattices.isonshell","text":"isonshell(L::RealLattice, p, r, o)\n\nDetermine whether a lattice point p is on a shell with radius r wrt. the origin o. A shell is defined as the collection of points with |(p-o)|≤r+a/2 where a is the lattice spacing.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.conicsection","page":"Lattices","title":"GrowthDynamics.Lattices.conicsection","text":"conicsection(L, points, Ω; axis, o)\n\nFilter those points that lie within a conic section of opening angle Ω around axis emanating from origin o.\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html#Evolving-populations","page":"Dynamics","title":"Evolving populations","text":"","category":"section"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"Routines to advance a population state for a number of time steps, or until a pre-specified condition is met.","category":"page"},{"location":"dynamics.html#Available-dynamics","page":"Dynamics","title":"Available dynamics","text":"","category":"section"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"All routines take a Population as their first and only positional argument, and further parameters like mutation rate as keyword arguments.","category":"page"},{"location":"dynamics.html#Spatial","page":"Dynamics","title":"Spatial","text":"","category":"section"},{"location":"dynamics.html#An-Eden-like-model","page":"Dynamics","title":"An Eden-like model","text":"","category":"section"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"LatticeDynamics.eden_with_density!","category":"page"},{"location":"dynamics.html#GrowthDynamics.LatticeDynamics.eden_with_density!","page":"Dynamics","title":"GrowthDynamics.LatticeDynamics.eden_with_density!","text":"eden_with_density!(state::Population)\n\nCells proliferate to neighboring lattice sites with a rate proportional to the number of  free neighboring sites. A time step is either a birth, death, or mutation-only event.\n\nA custom label function must be provided if genotypes are not integers.\n\nSee the 'extended help' for signatures of the various callbacks.\n\nKeyword arguments\n\nT::Int: number of steps to advance.\nd=0.0: death rate. Zero halts the dynamics after carrying capacity is reached.\nfitness=(population, old_genotype, new_genotype)->1.0: function that assigns a fitness value (default 1.0) to a new genotype. \nmu=0.0: mutation rate; either a function or number.\nlabel=(population, old_genotype) -> lastgenotype(population)+1: function that assigns the new genotype upon mutation. \nmakesnps=true: generate SNPs during the simulation?\nmu_type=[:poisson, :fixed]: number of mutations is fixed, or Poisson distributed.\ngenome_length=10^9: length of the genome.\nbaserate=1.0: progressing real time is measured in 1/baserate.\nprune_period=0: prune the phylogeny periodically after no. of steps, set to 0 to disable.\nprune_on_exit=true: prune before leaving the simulation.\nonstep: callback that is executed at the very beginning of every time step.\nonprebirth: callback that runs if a birth event is about to occur. Return value determines whether cell actually proliferates.\nonpostbirth: callback that runs at the very end of a proliferation event.\nondeath: callback that runs at the very end of a death event.\n\nExtended help\n\nMutations\n\nThe rate of mutations is steered by the keyword argument mu, which is either a number or a function.\n\nA number is automatically converted to an appropriate function. As a function it must have signature mu(population, old_genotype, I_old, I_new)->(rate, p_mutate)::Tuple{Float64, Float64} where\n\nold_genotype is the genotype of the parent cell\nI_old, I_new are the linear lattice indices of the parent and daughter cell.\n\nThis way the mutation rate can depend on position as well as on mutations present in the parental genome.\n\nThe output must be a tuple, where the first entry rate determines the number of mutations if mutations happen; the probability of which is given by the second entry p_mutate. The main reason for keeping these quantities separate is that one will often not generate SNPs during the simulation, because that process is rather costly, but generate them later on the basis of the final phylogeny.\n\nIf mu is a number, it is implicitely wrapped in a function that returns (mu, 1-exp(-mu)), i.e. the mutation probability is the probability of at least one event under a Poisson distribution with rate mu.\n\nSetting makesnps to true/false determines whether SNPs are generated during the simulation. If it is set to false, the first value returned by mu is inconsequential.\n\nFinally, label(population, old_genotype)->new_genotype assigns the designation to a newly entering genotype. It defaults to numbering genotypes consecutively. See also rename!.\n\nFitness\n\nWhen a new genotype enters due to a mutation event, it is assigned a fitness value given by a user-provides function (population, old_genotype, new_genotype)->Float64 passed as keyword argument fitness. For example, to inherit the fitness, one would provide  fitness=(p,og,ng)->p.meta[g=og; :fitness].\n\nCallbacks\n\nCallbacks are triggered at certain stages of the simulation loop:\n\nonstep(population)::Bool is executed at the beginning of each time step. If true is returned, the simulation ends.\nonprebirth(population, Iold)::Bool is executed when a birth event is triggered, but before it is executed. If false is returned, the cell  will not proliferate, but might still mutate.\nonpostbirth(population, Iold, Inew) is executed after proliferation and mutation are completed. Useful for collecting observables.\nondeath(population, Idead) is executed when a death event has finished.\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html#Non-spatial","page":"Dynamics","title":"Non-spatial","text":"","category":"section"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"LatticeDynamics.moran!\nLatticeDynamics.exponential!","category":"page"},{"location":"dynamics.html#GrowthDynamics.LatticeDynamics.moran!","page":"Dynamics","title":"GrowthDynamics.LatticeDynamics.moran!","text":"moran!(state::NoLattice{Int}; <keyword arguments>)\n\n(Generalized) Moran dynamics on an unstructured population. Birth and death events are independent until the carrying capacity (keyword argument K) is reached.  After that individuals begin replacing each other like in the classic Moran model.\n\nArguments\n\nT::Int: the number of steps to advance.\nd=0.0: death rate.\nK=0: Carrying capacity. Set to 0 for unlimited.\nfitness=(population, old_genotype, new_genotype)->1.0: function that assigns a fitness value (default 1.0) to a new genotype. \nmu=0.0: mutation rate; either a function or number.\nlabel=(population, old_genotype) -> lastgenotype(population)+1: function that assigns the new genotype upon mutation. \nmakesnps=true: generate SNPs during the simulation?\nmu_type=[:poisson, :fixed]: number of mutations is fixed, or Poisson distributed.\ngenome_length=10^9: length of the genome.\nbaserate=1.0: progressing real time is measured in 1/baserate.\nprune_period=0: prune the phylogeny periodically after no. of steps, set to 0 to disable.\nprune_on_exit=true: prune before leaving the simulation.\nonstep: callback that is executed at the very beginning of every time step.\nonprebirth: callback that runs if a birth event is about to occur. Return value determines whether cell actually proliferates.\nonpostbirth: callback that runs at the very end of a proliferation event.\nondeath: callback that runs at the very end of a death event.\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html#GrowthDynamics.LatticeDynamics.exponential!","page":"Dynamics","title":"GrowthDynamics.LatticeDynamics.exponential!","text":"exponential!(state::NoLattice{Int}; <keyword arguments>)\n\nRun exponential growth on an unstructered population until carrying capacity is reached. No death. \n\nEach generation consists of the following actions for every genotype:\n\nThe number of decendents is drawn from a binomial distribution with parameters n, the  population number of that genotype, and p given by 1-exp(-f/<f>) with fitness value f. That number as capped so as not to exceed the defined carrying capacity.\nOf those decendents the number of mutants is drawn from a binomial distribution according to the mutation rate mu.\n\nArguments\n\nT::Int: number of steps to advance.\nfitness=(population, old_genotype, new_genotype)->1.0: function that assigns a fitness value (default 1.0) to a new genotype. \nmu=0.0: mutation rate; either a function or number.\nlabel=(population, old_genotype) -> lastgenotype(population)+1: function that assigns the new genotype upon mutation. \nmakesnps=true: generate SNPs during the simulation?\nmu_type=[:poisson, :fixed]: number of mutations is fixed, or Poisson distributed.\ngenome_length=10^9: length of the genome.\nbaserate=1.0: progressing real time is measured in 1/baserate.\nprune_period=0: prune the phylogeny periodically after no. of steps, set to 0 to disable.\nprune_on_exit=true: prune before leaving the simulation.\nonstep: callback that is executed at the very beginning of every time step.\nondeath: callback that runs at the very end of a death event.\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html#Adding-your-own","page":"Dynamics","title":"Adding your own","text":"","category":"section"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"There is no particular interface or signature an evolution routine must adhere to.","category":"page"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"However, to avoid putting the lattice, metadata and phylogeny in an inconsistent state, a few tips should be followed","category":"page"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"Use the getter and setter methods for MetaData instead of manipulating the fields directly.\nUsing metadata[g=genotype; Val(:field)] is more performant than metadata[g=genotype; :field] if :field is constant, because   the former avoids dynamic dispatch.\nUse population[index] (= genotype) to get/set the genotype of a cell at a position.   Do not manipulate population.lattice.data directly.\nPrefer add_genotype! over push!.\nUse remove_genotype!.\nFor performance reasons SNPs are either Vector{Int} or nothing. Check for the latter with hassnps before  adding new ones.\nNot a must, but don't forget to advance the step/real time counters population.t and population.treal after each simulation step.","category":"page"},{"location":"observables.html#Observables","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"observables.html","page":"Observables","title":"Observables","text":"List of built-in observables. They take a Population as the first and often only argument.","category":"page"},{"location":"observables.html","page":"Observables","title":"Observables","text":"    Pages = [\"observables.md\"]","category":"page"},{"location":"observables.html","page":"Observables","title":"Observables","text":"    Modules = [GrowthDynamics.Observables]","category":"page"},{"location":"observables.html#GrowthDynamics.Observables.allele_fractions","page":"Observables","title":"GrowthDynamics.Observables.allele_fractions","text":"Dictionary of (SNP, freq).\n\n\n\n\n\n","category":"function"},{"location":"observables.html#GrowthDynamics.Observables.allele_size","page":"Observables","title":"GrowthDynamics.Observables.allele_size","text":"Dictionary (SNP, population count)\n\n\n\n\n\n","category":"function"},{"location":"observables.html#GrowthDynamics.Observables.allele_spectrum-Tuple{Population}","page":"Observables","title":"GrowthDynamics.Observables.allele_spectrum","text":"allele_spectrum(state;[ threshold=0.0, read_depth=total_population_size(state)])\n\nReturn a DataFrame with count, frequency of every polymorphism. Additionally sample from the population.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.common_snps-Tuple{Population}","page":"Observables","title":"GrowthDynamics.Observables.common_snps","text":"common_snps(::Population; filterdead=true)\n\nList polymorphisms that are common to all genotypes.\n\nOptional arguments:\n\nfilterdead=true: exclude unpopulated genotypes?\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.counts_on_shells-Union{Tuple{A}, Tuple{G}, Tuple{Population{G, A}, G}, Tuple{Population{G, A}, G, Any}, Tuple{Population{G, A}, G, Any, Any}} where {G, A}","page":"Observables","title":"GrowthDynamics.Observables.counts_on_shells","text":"counts_on_shells(state, g, [o, a])\n\nReturn a dictionary i=>count mapping the ith shell to the number of cells of genotype g on it.\n\nThe \"shell number\" of a point is the integer closest to |p-o|/a.\n\nKeyword arguments\n\no=midpointcoord(state.lattice): center of shells\na=spacing(state.lattice): spacing of shells\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.explode_into_shells-Union{Tuple{T}, Tuple{Vector{T}, Any, Any}} where T<:(GeometryBasics.Pointf)","page":"Observables","title":"GrowthDynamics.Observables.explode_into_shells","text":"explode_into_shells(v, o, a; r0=)\n\nTake a vector of cartesian coordinates v, center them around the midpoint o, and return a dictionary radius=>coordinates where r0<= radius <= max(||v||) in increments of a. \n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.ipositions-Tuple{Population, Any}","page":"Observables","title":"GrowthDynamics.Observables.ipositions","text":"ipositions(state, g)\n\nReturns lattice indices of cells of genotype g.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.living_ancestor-Tuple{Population, Any}","page":"Observables","title":"GrowthDynamics.Observables.living_ancestor","text":"Earliest living ancestor.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.mean_pairwise-Tuple{Population}","page":"Observables","title":"GrowthDynamics.Observables.mean_pairwise","text":"Diversity (mean pairwise difference of mutations) of a population.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.mrca-Tuple{Population, Integer, Integer}","page":"Observables","title":"GrowthDynamics.Observables.mrca","text":"Return index of the most recent common ancestor between (i,j) in a phylogeny.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.mrca-Tuple{Population}","page":"Observables","title":"GrowthDynamics.Observables.mrca","text":"Return index of the most recent common ancestor in a phylogeny.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.npolymorphisms-Tuple{Population}","page":"Observables","title":"GrowthDynamics.Observables.npolymorphisms","text":"npolymorphisms(S::Population)\n\nNumber of polymrphisms\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.pairwise-Tuple{Population, Any, Any}","page":"Observables","title":"GrowthDynamics.Observables.pairwise","text":"pairwise(S::Population, i, j)\n\nNumber of pairwise genomic differences between genotype indices i,j.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.pairwise-Tuple{Population}","page":"Observables","title":"GrowthDynamics.Observables.pairwise","text":"pairwise(S::Population)\n\nMatrix of pairwise differences.   filterdead: Do not include extinct genotypes.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.polymorphisms-Tuple{Population}","page":"Observables","title":"GrowthDynamics.Observables.polymorphisms","text":"polymorphisms(S::Population)\n\nVector of polymorphisms (segregating sites).\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.popsize_on_shells-Union{Tuple{T}, Tuple{Population{T, <:RealLattice}, Any}} where T","page":"Observables","title":"GrowthDynamics.Observables.popsize_on_shells","text":"popsize_on_shells(T, outer, [o=midpoint(T.lattice)])\n\nCreates a dictionary genotype => trajectory where trajectory is a vector of population size. trajectory[r] is the the population size on a L2-norm shell of radius r around o.\n\nr ranges between 1..outer in increments of a (defaults to the lattice spacing).\n\nSet deleteone/zero=false to keep the wildtype/count empty sites.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.population_size-Tuple{Population, Any}","page":"Observables","title":"GrowthDynamics.Observables.population_size","text":"Dictionary (genotype, population size)\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.positions-Union{Tuple{N}, Tuple{T}, Tuple{Population{T, <:AbstractLattice{T, N}}, Any}} where {T, N}","page":"Observables","title":"GrowthDynamics.Observables.positions","text":"positions(state, g)\n\nReturns coordinates of cells of genotype g.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.sampled_allele_fractions","page":"Observables","title":"GrowthDynamics.Observables.sampled_allele_fractions","text":"sampled_allele_fractions(S::Population[, t=0, samples=length(S.meta.npops)])\n\nRandomly sample genotypes(!) and calculate frequencies of contained SNPs. Return a dictionary (SNP, freq).\n\n\n\n\n\n","category":"function"},{"location":"observables.html#GrowthDynamics.Observables.tajimasd-Tuple{Any, Any, Any}","page":"Observables","title":"GrowthDynamics.Observables.tajimasd","text":"See https://en.wikipedia.org/wiki/Tajima%27s_D\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.Observables.total_population_size-Tuple{Population}","page":"Observables","title":"GrowthDynamics.Observables.total_population_size","text":"Total population size. Duh.\n\n\n\n\n\n","category":"method"},{"location":"phylogenies.html#Phylogenies","page":"Phylogenies","title":"Phylogenies","text":"","category":"section"},{"location":"phylogenies.html","page":"Phylogenies","title":"Phylogenies","text":"A state::Population has a phylogenetic tree and metadata about the genotypes attached.   Any time evolution routine should take care of maintaining this tree and metadata.","category":"page"},{"location":"phylogenies.html","page":"Phylogenies","title":"Phylogenies","text":"The vertices v are always numbered from 1 and correspond to the genotype meta[v]. Use index(@ref) to find the id of a genotype.\nInserting a new genotype into the population via push!(::Population, newgenotype) will add a vertex to the phylogeny, but won't create an edge that connects it to the tree.","category":"page"},{"location":"phylogenies.html","page":"Phylogenies","title":"Phylogenies","text":"warning: Warning\nUse add_edge!(state, newgenotype, parent) (preferred) or add_edge!(state.phylogeny, newgenotype_id, parent_id) to connect the new genotype to the phylogeny.","category":"page"},{"location":"phylogenies.html","page":"Phylogenies","title":"Phylogenies","text":"    Modules = [GrowthDynamics.Phylogenies]","category":"page"},{"location":"phylogenies.html#GrowthDynamics.Phylogenies.df_traversal!-Tuple{Vector{Int64}, Graphs.SimpleGraphs.SimpleDiGraph}","page":"Phylogenies","title":"GrowthDynamics.Phylogenies.df_traversal!","text":"See also df_traversal\n\n\n\n\n\n","category":"method"},{"location":"phylogenies.html#GrowthDynamics.Phylogenies.df_traversal-Tuple{Graphs.SimpleGraphs.SimpleDiGraph}","page":"Phylogenies","title":"GrowthDynamics.Phylogenies.df_traversal","text":"df_traversal(G::SimpleDiGraph; root=1)\n\nTraverse a phylogenetic tree depth first, starting at vertex root which defaults to 1.\n\nReturn a vector of vertices.\n\n\n\n\n\n","category":"method"},{"location":"phylogenies.html#GrowthDynamics.Phylogenies.has_children-Tuple{Any, Any}","page":"Phylogenies","title":"GrowthDynamics.Phylogenies.has_children","text":"Does a genotype have any children?\n\n\n\n\n\n","category":"method"},{"location":"phylogenies.html#GrowthDynamics.Phylogenies.sample_ztp-Tuple{Float64}","page":"Phylogenies","title":"GrowthDynamics.Phylogenies.sample_ztp","text":"sample_ztp(lambda)\n\nReturn one sample of a zero-truncated Poisson distribution with rate λ.\n\nSee \n\nNote: Should be in Distributions.jl.\n\n\n\n\n\n","category":"method"},{"location":"phylogenies.html#Pruning","page":"Phylogenies","title":"Pruning","text":"","category":"section"},{"location":"phylogenies.html","page":"Phylogenies","title":"Phylogenies","text":"In the course of a simulation run, especially with large mutation rates, the phylogenetic tree and metadata can become quite extensive. They contain an entry for every genotype that ever was in existence, thus representing the full history of the population. Eventually performance will deteriorate. If the full tree is not needed, one may opt to occasionally prune the tree and metadata, that is, remove internal nodes that have died out.","category":"page"},{"location":"phylogenies.html","page":"Phylogenies","title":"Phylogenies","text":"See also the keyword arguments prune_period and prune_on_exit.","category":"page"},{"location":"phylogenies.html","page":"Phylogenies","title":"Phylogenies","text":"prune_phylogeny!","category":"page"},{"location":"phylogenies.html#GrowthDynamics.Populations.prune_phylogeny!","page":"Phylogenies","title":"GrowthDynamics.Populations.prune_phylogeny!","text":"prune_phylogeny!(S::Population)\n\nRemove unpopulated genotypes from the phylogenetic tree and meta data.   Any gap in the phylogeny is bridged.\n\n\n\n\n\n","category":"function"},{"location":"states.html#Populations","page":"Populations","title":"Populations","text":"","category":"section"},{"location":"states.html","page":"Populations","title":"Populations","text":"A population is a collection of","category":"page"},{"location":"states.html","page":"Populations","title":"Populations","text":"either a lattice<:RealLattice if the model is spatial (see lattices), or a dummy placeholder NoLattice if it is not.\na phylogenetic tree, which is a directed graph where the root(s) represent the wild type(s).\nmetadata about the population and its genetics. See Metadata.\nthe time the state has been evolved for by invoking dynamics on it.","category":"page"},{"location":"states.html","page":"Populations","title":"Populations","text":"They are of type Population.","category":"page"},{"location":"states.html","page":"Populations","title":"Populations","text":"It is normally not required to manipulate metadata, phylogeny or lattice directly. Convenient methods to manipulate state are provided.","category":"page"},{"location":"states.html","page":"Populations","title":"Populations","text":"using Graphs\nusing GrowthDynamics\nusing GrowthDynamics.Populations\nusing GrowthDynamics.Lattices","category":"page"},{"location":"states.html","page":"Populations","title":"Populations","text":"    state, _ = uniform(CubicLattice, 32; g=0)\n\n    # fails because the new genotype is yet unknown\n    state[16,16,16] = 1\n\n    # make it known first\n    # last paremeter is the parental genotype\n    # because there is none yet, set it to `nothing`\n    add_genotype!(state, 1, nothing)\n    state[16,16,16] = 1;\n\n    state.meta\n\n    state[15:17,15:17,15:17]\n\n    push!(state, 2)\n    state[1:size(state,1), 1, 1] .= 2;\n\n    state.meta","category":"page"},{"location":"states.html#Convenience-constructors","page":"Populations","title":"Convenience constructors","text":"","category":"section"},{"location":"states.html","page":"Populations","title":"Populations","text":"A handful of methods to generate common geometries are provided. They return a tuple (population,auxilliary). The latter holds information that might be nice to have. It is often nothing, but for example spherer returns a vector with all indices contained in the ball.","category":"page"},{"location":"states.html","page":"Populations","title":"Populations","text":"    uniform\n    spheref\n    spherer\n    single_center\n    half_space\n    sphere_with_single_mutant_on_outer_shell\n    sphere_with_diverse_outer_shell","category":"page"},{"location":"states.html#GrowthDynamics.Populations.uniform","page":"Populations","title":"GrowthDynamics.Populations.uniform","text":"uniform(T, L; g=0, a=1.0)\n\nA population on a lattice of type T with linear extension L, filled with genotype g.\n\nReturn (population, nothing).\n\nExample\n\njulia> uniform(HexagonalLattice, 128; g=1)\n(HexagonalLattice{Int64, Matrix{Int64}}\n1\tgenotypes\n16641\tpopulation, nothing)\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.Populations.spheref","page":"Populations","title":"GrowthDynamics.Populations.spheref","text":"spheref(T, L::Int; r = 0, g1=0, g2=1) where LT<:Lattices.RealLattice\n\nFill lattice of type T (e.g CubicLattice) with genotype g1 and put a (L2-)ball with genotype g2 that occupies approx. a fraction f of the lattice at the center.\n\nReturn (population, idx_ball) with idx_ball being the indices of sites within the ball.\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.Populations.spherer","page":"Populations","title":"GrowthDynamics.Populations.spherer","text":"spherer(T, L::Int; r = 0, g1=0, g2=1) where LT<:Lattices.RealLattice\n\nFill lattice of type T (e.g CubicLattice) with genotype g1 and put a (L2-)ball of approx. radius r with genotype g2 at the center.\n\nReturn (population, idx_ball) with idx_ball being the indices of sites within the ball.\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.Populations.single_center","page":"Populations","title":"GrowthDynamics.Populations.single_center","text":"single_center(T, L; g1=1, g2=2)\n\nA single cell of genotype g2 at the midpoint of a lattice of type T filled with g1.\n\nReturn (population, midpoint::Index)\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.Populations.half_space","page":"Populations","title":"GrowthDynamics.Populations.half_space","text":"half_space(T, L; g1=1, g2=2)\n\nA population of genotype g1 on a lattice of type T.  Fill the last dimension with g2 up to fraction f\n\nReturn (population, fill_to) with fill_to defined as state[:,..., 1:fill_to] == g2 and state[:,..., fill_to+1:end] == g1.\n\nExample\n\njulia> using GrowthDynamics.Populations\n\njulia> state = half_space(CubicLattice, 32, f=1/4, g1=1, g2=2)[1]\nCubicLattice{Int64, Array{Int64, 3}}\n2\tgenotypes\n35937\tpopulation\n\njulia> state.meta\n2-element MetaData{Int64}:\n (genotype = 1, npop = 27225, fitness = 1.0, snps = nothing, age = (0, 0.0))\n (genotype = 2, npop = 8712, fitness = 1.0, snps = nothing, age = (0, 0.0))\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.Populations.sphere_with_single_mutant_on_outer_shell","page":"Populations","title":"GrowthDynamics.Populations.sphere_with_single_mutant_on_outer_shell","text":"sphere_with_single_mutant_on_outer_shell(T, L::Int; r, s=1.0)\n\nA lattice of type T (e.g CubicLattice) with an (L2-)ball of genotype 1 and radius r at the center. One random site on the outermost shell is populated  with genotype 2 that has fitness s.\n\nReturn (population, (idx_shell, idx_mutant)) with idx_shell being the indices of the outer shell, and idx_mutant the index of the mutant genotype.\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.Populations.sphere_with_diverse_outer_shell","page":"Populations","title":"GrowthDynamics.Populations.sphere_with_diverse_outer_shell","text":"sphere_with_diverse_outer_shell(T, L; r)\n\nA lattice of type T (e.g CubicLattice) with an (L2-)ball of genotype 1 and radius r at the center. Each site on the outermost shell is populated consecutively with  a different genotype, starting from 2.\n\nReturn (population, idx_shell) with idx_shell being the indices of the outer (\"diverse\") shell.\n\n\n\n\n\n","category":"function"},{"location":"states.html","page":"Populations","title":"Populations","text":"An initial population without spatial structure can be constructed with","category":"page"},{"location":"states.html","page":"Populations","title":"Populations","text":"nolattice_state","category":"page"},{"location":"states.html#GrowthDynamics.Populations.nolattice_state","page":"Populations","title":"GrowthDynamics.Populations.nolattice_state","text":"nolattice_state()\n\nModel without spatial structure.   Populated with one individual of genotype 1 with fitness 1.0.\n\n\n\n\n\n","category":"function"},{"location":"states.html#API","page":"Populations","title":"API","text":"","category":"section"},{"location":"states.html#Manipulating-genotypes","page":"Populations","title":"Manipulating genotypes","text":"","category":"section"},{"location":"states.html","page":"Populations","title":"Populations","text":"    Population\n    add_genotype!\n    remove_genotype!\n    push!","category":"page"},{"location":"states.html#GrowthDynamics.Populations.Population","page":"Populations","title":"GrowthDynamics.Populations.Population","text":"Population{G, T}\n\nRepresents a population on a lattice of type T with genotypes of data type G.\n\nFields\n\nlattice<:Lattices.AbstractLattice\nphylogeny: directed graph recording the ancestry of genotypes\nmeta::MetaData: metadata such as fitnesses, mutations, etc. See MetaData.\nt::Int: age in timesteps\ntreal::Float64: age in \"real\" time.\nobservables: dictionary to store observables in\n\n\n\n\n\n","category":"type"},{"location":"states.html#GrowthDynamics.Populations.add_genotype!","page":"Populations","title":"GrowthDynamics.Populations.add_genotype!","text":"add_genotype!(S::Population, G, parent)\n\nAdd genotype G to the population and connect it to parent in the phylogeny. G is either a genotype or a full MetaDatum. parent defaults to the first genotype, i.e. the root of the phylogenetic tree. If parent=nothing, the genotype will not be connected to the tree.\n\nSee also: MetaDatum, remove_genotype!\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.Populations.remove_genotype!","page":"Populations","title":"GrowthDynamics.Populations.remove_genotype!","text":"remove_genotype!(S::Population, g; bridge=true)\n\nRemove genotype from the population. Discards it from meta data, prunes it from the  phylogeny, and sets all corresponding sites of the lattice to zero.\n\nIf bridge=true (default), the gap in the phylogeny is bridged with new edges.\n\nThrow an exception if the requested genotype does not exist.\n\nReturn true if successful, else false.\n\n\n\n\n\n","category":"function"},{"location":"states.html#Base.push!","page":"Populations","title":"Base.push!","text":"Add a new unconnected genotype to a Population.\n\n\n\n\n\n","category":"function"},{"location":"states.html#Methods-to-add-mutations","page":"Populations","title":"Methods to add mutations","text":"","category":"section"},{"location":"states.html","page":"Populations","title":"Populations","text":"add_snps!\nannotate_snps!\nannotate_lineage!","category":"page"},{"location":"states.html#GrowthDynamics.Populations.add_snps!","page":"Populations","title":"GrowthDynamics.Populations.add_snps!","text":"add_snps!(state::Population, g, μ)\n\nRandomize and add mutations to genotype g, or replace them. μ is the genome wide mutation rate (Poisson) or mutation count (fixed).\n\nNote: allow_multiple is much faster if the number of mutations already present is large.\n\nKeyword arguments\n\nL=10^9: length of the genome\nallow_multiple=false: allow for a site to mutate more than once.\nkind=:poisson: either :poisson or :fixed\nreplace=false: replace existing SNPs.\n\n\n\n\n\nadd_snps!(state::Population, g, v::Vector{Int})\n\nAdd mutations v to genotype g. No checks for duplications are performed. \n\nReturn a vector of all mutations. \n\n\n\n\n\n","category":"function"},{"location":"index.html#GrowthDynamics.jl","page":"Overview","title":"GrowthDynamics.jl","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"This package implements various models of growing and evolving populations, both with and without spatial structure.","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"A number of useful observables are defined.","category":"page"},{"location":"index.html#Quick-Start","page":"Overview","title":"Quick Start","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"Let's give an overview of the components acting together.","category":"page"},{"location":"index.html#States","page":"Overview","title":"States","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"A state is a structure comprised of a lattice (see Lattices), each entry representing a member of the population, its value representing its genotype, and various metadata. In unstructured populations the lattice is simply a dummy.","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"The metadata store information about the current state of the various genotypes, like number of individuals present, their fitness, and so on. Furthermore, a phylogenetic tree is recorded during simulation, enabling access to observables like most-recent common ancestors, or tracking of lineages.","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"import GrowthDynamics.Populations: spheref\nimport GrowthDynamics.Lattices: HexagonalLattice\nusing GrowthDynamics.LatticeDynamics\nusing GrowthDynamics.Observables\nimport DataFrames: first # hide\n\nstate, _ = spheref(HexagonalLattice, 128, f=1/10, g1=0, g2=1)","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"This prepares a state on a two-dimensional hexagonal lattice of size 128^2 that is unoccupied (genotype 0 is per definition understood as unoccupied.) except for a centered disk of genotype 1 that comprises ~1/10 of the total population.","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"Every mutation event introduces a new genotype. They are by default labeled consecutively by integers, but custom labels are possible.","category":"page"},{"location":"index.html#Dynamics","page":"Overview","title":"Dynamics","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"Now evolve the population.","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"eden_with_density!(state;\n  T=128^2, # timesteps\n  mu=1e0,  # mutation rate per genome (not site!)\n  d=1/100, # death rate\n  fitness=(s,g_old,g_new)->1.0 + 0.1*randn() # function to assign fitness to new genotypes\n)\n\nshow(state)","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"We can plot (done using Makie.jl) the distribution of fitness values to check if it conforms to expectation","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"using CairoMakie #hide\nhist(state.meta[:, :fitness], axis=(xlabel=\"Fitness\", ylabel=\"Count\")) #hide","category":"page"},{"location":"index.html#Observables","page":"Overview","title":"Observables","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"# number of polymorphisms and diversity\nnpolymorphisms(state), mean_pairwise(state)","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"# alleles with frequency larger 0.01\nfirst(sort(allele_spectrum(state, threshold=0.01), :fpop), 6)","category":"page"},{"location":"metadata.html#Metadata","page":"Metadata","title":"Metadata","text":"","category":"section"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"Every Population has MetaData attached. They store for every genotype","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"population count. While in principle redundant, it is significantly cheaper to keep a tally during a simulation than to iterate the entire lattice.\nfitness value\nTODO: death rate\nmutations: either nothing, or a vector of Int if mutations are present\nthe time when the genotype entered the population","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"Additionally, the field misc is a dictionary for storing arbitrary user-defined key-value pairs.","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"note: Implementation detail\nAside from using the value of genotype to index into metadata, one can use the linear index of the underlying array in which they are stored. The function index queries the linear index of a given genotype. An example is given below.","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"warning: Warning\nWhile insertions only happen at the end and leave linear indices unchanged, deletions will shift them. You should not rely on a particular index mapping to a given genotype when deletions are performed.","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"Convenient getter and setter are provided. Let's demonstrate on an example similar to the one from the Quick Start section, but label genotypes with strings of fixed length (from InlineStrings.jl)","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"import Random\nRandom.seed!(1234)\n\nimport GrowthDynamics.Populations: spheref\nimport GrowthDynamics.Lattices: HexagonalLattice\nusing GrowthDynamics.LatticeDynamics\nusing GrowthDynamics.Observables\nimport DataFrames: first # hide","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"using InlineStrings\nimport Base: zero\nzero(::Type{String7}) = String7(\"00-00\")\n\nstate, _ = spheref(HexagonalLattice, 128, f=1/10, g1=String7(\"00-00\"), g2=String7(\"00-AA\"))\n\nfunction newlabel(state,g)\n  l = String7( join(rand('0':'9',2))*\"-\"*join(rand('A':'Z',2)) )\n  while l in state.meta[:, :genotype]\n    l = String7( join(rand('0':'9',2))*\"-\"*join(rand('A':'Z',2)) )\n  end\n  return l\nend\n\neden_with_density!(state;\n  label=newlabel,\n  T=1024, # timesteps\n  mu=1e0,  # mutation rate per genome (not site!)\n  d=1/100, # death rate\n  fitness=(s,g_old,g_new)->1.0 + 0.1*randn() # function to assign fitness to new genotypes\n)\n\nstate.meta","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"Query according to index","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"state.meta[2, :genotype]\n\nstate.meta[5:10, :npop]","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"or genotype","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"state.meta[g=\"46-YQ\"]\n\nstate.meta[g=\"46-YQ\", :fitness] = 1.1","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"note: Note\nIn places where performance is paramount, getter and setter should be called like state.meta[2, Val(:genotype)] to circumvent dynamic dispatch.Alternatively, getgenotype(state, id), setgenotype!(state, id), etc. are provided.","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"Because MetaData implements Julia's array interface, iterating is supported, and because each MetaDatum is a NamedTuple, conversion to e.g. a DataFrame is straightforward","category":"page"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"using DataFrames\n\nfilter(v->v.npop>10, state.meta) |> DataFrame","category":"page"},{"location":"metadata.html#API","page":"Metadata","title":"API","text":"","category":"section"},{"location":"metadata.html","page":"Metadata","title":"Metadata","text":"MetaData\nMetaDatum\nindex(::MetaData{T}, ::T) where {T}\nindex!\nrename!\nhassnps\nlastgenotype\nlength","category":"page"},{"location":"metadata.html#GrowthDynamics.Populations.MetaData","page":"Metadata","title":"GrowthDynamics.Populations.MetaData","text":"MetaData{T}\n\nIndexable structure to store information about a population.\n\nAccess\n\nUse meta[id, :field] or meta[g=G, :field] to access and set information for genotype G, or the genotype with id id respectively.\n\nid is also the number of the vertex in the phylogeny corresponding to a given genotype.\n\n:field is one of\n\n:npop - population size\n:fitness - fitness value\n:genotype - genotype corresponding to a given id\n:snps: - vector of integers representing mutations a genotype carries.  nothing if no mutations are present.\n:age: tuple of (timestep, realtime) of when the genotype was first instantiated.\n\nUseful for putting lengths on the branches of a phylogeny.\n\nAdditionally, a global field meta.misc::Dict{Any,Any} exists to store arbitrary, user-defined information.\n\nSee also MetaDatum\n\n\n\n\n\n","category":"type"},{"location":"metadata.html#GrowthDynamics.Populations.MetaDatum","page":"Metadata","title":"GrowthDynamics.Populations.MetaDatum","text":"MetaDatum{T,S}\n\nNamedTuple to store information about a single genotype of type T that carries mutations of type S (default Int).\n\n\n\n\n\n","category":"type"},{"location":"metadata.html#Dictionaries.index-Union{Tuple{T}, Tuple{MetaData{T}, T}} where T","page":"Metadata","title":"Dictionaries.index","text":"index(M, g)\n\nReturn the index of genotype g, or nothing if g is not in meta data M.\n\n\n\n\n\n","category":"method"},{"location":"metadata.html#GrowthDynamics.Populations.index!","page":"Metadata","title":"GrowthDynamics.Populations.index!","text":"index!(::MetaData)\n\nReindex the metadata.\n\n\n\n\n\n","category":"function"},{"location":"metadata.html#DataFrames.rename!","page":"Metadata","title":"DataFrames.rename!","text":"rename!(S, g1 => g2)\n\nRename genotype g1 to g2.\n\n\n\n\n\n","category":"function"},{"location":"metadata.html#GrowthDynamics.Populations.hassnps","page":"Metadata","title":"GrowthDynamics.Populations.hassnps","text":"hassnps(M::MetaData; g)\n\nReturn true if genotype contains mutations.\n\n\n\n\n\n","category":"function"},{"location":"metadata.html#GrowthDynamics.Populations.lastgenotype","page":"Metadata","title":"GrowthDynamics.Populations.lastgenotype","text":"lastgenotype(M::MetaData)\n\nReturn genotype that was added last.\n\n\n\n\n\nGenotype that was last added to the population.\n\n\n\n\n\n","category":"function"},{"location":"metadata.html#Base.length","page":"Metadata","title":"Base.length","text":"length(L::RealLattice)\n\nNumber of elements of L.data.\n\n\n\n\n\n","category":"function"}]
}
