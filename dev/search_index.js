var documenterSearchIndex = {"docs":
[{"location":"lattices.html#lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"    CurrentModule = GrowthDynamics.Lattices","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Each agent occupies a site on a lattice. They provide a mapping between coordinates and indices of the underlying array.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"N.B.: The provided structures are not true lattices, since they do not extend arbitrarily, but have finite size.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Currently, the following lattice types are provided","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"LineLattice\nHexagonalLattice\nCubicLattice\nFCCLattice","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"These are subtypes of RealLattice. Additionally, a NoLattice type is provided for situations without a spatial structure.","category":"page"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"warning: Warning\nAvoid manipulating the data field of a lattice directly. Doing so easily leads to an inconsistent state between lattice and meta data.Use the getter and setter methods for TumorConfiguration instead.","category":"page"},{"location":"lattices.html#Lattice-Types","page":"Lattices","title":"Lattice Types","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"    CubicLattice\n    FCCLattice\n    HexagonalLattice\n    LineLattice","category":"page"},{"location":"lattices.html#GrowthDynamics.Lattices.CubicLattice","page":"Lattices","title":"GrowthDynamics.Lattices.CubicLattice","text":"CubicLattice\n\nThree dimensional primitive cubic lattice. Each site has six equidistant neighbors with a fourfold rotational symmetry in each of the three planes.\n\nSee https://en.wikipedia.org/wiki/Cubiccrystalsystem\n\nFields\n\na: lattice constant\ndata: underlying array\n\nExample\n\njulia> using GrowthDynamics.Lattices\n\njulia> l = CubicLattice(1/2, ones(16,16,16))\nCubicLattice{Float64, Array{Float64, 3}}(0.5, [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; … ;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0])\n\njulia> neighbors(l, (8,8,8))\n6-element StaticArrays.MVector{6, CartesianIndex{3}} with indices SOneTo(6):\n CartesianIndex(7, 8, 8)\n CartesianIndex(9, 8, 8)\n CartesianIndex(8, 7, 8)\n CartesianIndex(8, 9, 8)\n CartesianIndex(8, 8, 7)\n CartesianIndex(8, 8, 9)\n\njulia> coord.(Ref(l), ans)\n6-element StaticArrays.MVector{6, GeometryBasics.Point{3, Float32}} with indices SOneTo(6):\n [3.0, 3.5, 3.5]\n [4.0, 3.5, 3.5]\n [3.5, 3.0, 3.5]\n [3.5, 4.0, 3.5]\n [3.5, 3.5, 3.0]\n [3.5, 3.5, 4.0]\n\n\n\n\n\n","category":"type"},{"location":"lattices.html#GrowthDynamics.Lattices.FCCLattice","page":"Lattices","title":"GrowthDynamics.Lattices.FCCLattice","text":"FCCLattice\n\nThree dimensional face-centered cubic lattice. Each site has twelve neighbors.\n\nSee https://en.wikipedia.org/wiki/Cubiccrystalsystem\n\nFields\n\na: lattice constant\ndata: underlying array\n\nExample\n\njulia> using GrowthDynamics.Lattices\n\njulia> l = FCCLattice(1/2, ones(16,16,16))\nFCCLattice{Float64, Array{Float64, 3}}(0.5, [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; … ;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0;;; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0])\n\njulia> neighbors(l, (8,8,8))\n12-element StaticArrays.MVector{12, CartesianIndex{3}} with indices SOneTo(12):\n CartesianIndex(7, 8, 8)\n CartesianIndex(9, 8, 8)\n CartesianIndex(9, 7, 8)\n CartesianIndex(7, 7, 8)\n CartesianIndex(7, 8, 9)\n CartesianIndex(8, 7, 9)\n CartesianIndex(9, 8, 9)\n CartesianIndex(8, 8, 9)\n CartesianIndex(7, 8, 7)\n CartesianIndex(8, 7, 7)\n CartesianIndex(9, 8, 7)\n CartesianIndex(8, 8, 7)\n\njulia> coord.(Ref(l), ans)\n12-element StaticArrays.MVector{12, GeometryBasics.Point{3, Float32}} with indices SOneTo(12):\n [1.5, 3.75, 1.75]\n [2.0, 3.75, 1.75]\n [2.0, 3.25, 1.75]\n [1.5, 3.25, 1.75]\n [1.5, 3.5, 2.0]\n [1.75, 3.25, 2.0]\n [2.0, 3.5, 2.0]\n [1.75, 3.75, 2.0]\n [1.5, 3.5, 1.5]\n [1.75, 3.25, 1.5]\n [2.0, 3.5, 1.5]\n [1.75, 3.75, 1.5]\n\n\n\n\n\n","category":"type"},{"location":"lattices.html#GrowthDynamics.Lattices.HexagonalLattice","page":"Lattices","title":"GrowthDynamics.Lattices.HexagonalLattice","text":"HexagonalLattice\n\nEach site has six equidistant neighbors with a sixfold rotational symmetry.\n\nSee https://en.wikipedia.org/wiki/Hexagonal_lattice\n\nFields\n\na: lattice constant\ndata: underlying array\n\nExample\n\njulia> using GrowthDynamics.Lattices\n\njulia> l = HexagonalLattice(1/2, ones(32,32))\nHexagonalLattice{Float64, Matrix{Float64}}(0.5, [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0])\n\njulia> neighbors(l, (16,16))\n6-element StaticArrays.MVector{6, CartesianIndex{2}} with indices SOneTo(6):\n CartesianIndex(15, 16)\n CartesianIndex(15, 17)\n CartesianIndex(16, 17)\n CartesianIndex(17, 17)\n CartesianIndex(17, 16)\n CartesianIndex(16, 15)\n\njulia> coord.(Ref(l), ans)\n6-element StaticArrays.MVector{6, GeometryBasics.Point{2, Float32}} with indices SOneTo(6):\n [7.5, 6.0621777]\n [8.0, 6.0621777]\n [8.25, 6.4951906]\n [8.0, 6.928203]\n [7.5, 6.928203]\n [7.25, 6.4951906]\n\n\n\n\n\n","category":"type"},{"location":"lattices.html#GrowthDynamics.Lattices.LineLattice","page":"Lattices","title":"GrowthDynamics.Lattices.LineLattice","text":"LineLattice\n\nOne dimensional lattice.\n\nFields\n\na: lattice spacing\ndata\n\n\n\n\n\n","category":"type"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"Each lattice type derives from AbstractLattice and implements the following methods","category":"page"},{"location":"lattices.html#Common-Methods","page":"Lattices","title":"Common Methods","text":"","category":"section"},{"location":"lattices.html","page":"Lattices","title":"Lattices","text":"    coord\n    index\n    coordination\n    dimension\n    midpoint\n    midpointcoord\n    neighbors\n    neighbors!\n    nneighbors\n    density","category":"page"},{"location":"lattices.html#GrowthDynamics.Lattices.coord","page":"Lattices","title":"GrowthDynamics.Lattices.coord","text":"coord(L, I)\n\nCoordinate of index I on the lattice L. I is either a tuple of integers, or an appropriate CartesianIndex.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#Dictionaries.index","page":"Lattices","title":"Dictionaries.index","text":"index(L, p)\n\nIndex of the coordinate p closest to the nearest site on lattice L. p is a GeometryBasics.Point.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.coordination","page":"Lattices","title":"GrowthDynamics.Lattices.coordination","text":"Coordination number of the lattice.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.dimension","page":"Lattices","title":"GrowthDynamics.Lattices.dimension","text":"Dimension of the lattice. Functionally equivalent to ndims(lattice.data).\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.midpoint","page":"Lattices","title":"GrowthDynamics.Lattices.midpoint","text":"midpoint(L)\n\nReturn the index of the point nearest to the geometeric center of the lattice L.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.midpointcoord","page":"Lattices","title":"GrowthDynamics.Lattices.midpointcoord","text":"midpointcoord(L)\n\nReturn the coordinate of the point nearest to the geometeric center of the lattice L.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.neighbors","page":"Lattices","title":"GrowthDynamics.Lattices.neighbors","text":"neighbors(L::RealLattice, I)\n\nVector of neighbors of index I. ReturnsVector{CartesianIndex{dimension(L)}}``.\n\nDoes not check for bounds.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.neighbors!","page":"Lattices","title":"GrowthDynamics.Lattices.neighbors!","text":"neighbors!(n, L, I)\n\nIn-place version of neighbors.\n\nUse n = Neighbors(L) to allocate an appropriate vector.\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.nneighbors","page":"Lattices","title":"GrowthDynamics.Lattices.nneighbors","text":"nneighbors(L, I)\n\nBoundary-aware number of nearest neighbors of site I on lattice L. \n\nExample\n\njulia> using GrowthDynamics.Lattices\n\njulia> l = HexagonalLattice(1/2, ones(32,32))\nHexagonalLattice{Float64, Matrix{Float64}}(0.5, [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0])\n\njulia> nneighbors(l, (5,5))\n6\n\njulia> nneighbors(l, (1,5))\n4\n\njulia> nneighbors(l, (1,1))\n2\n\n\n\n\n\n","category":"function"},{"location":"lattices.html#GrowthDynamics.Lattices.density","page":"Lattices","title":"GrowthDynamics.Lattices.density","text":"density(L::RealLattice{T}, I)\n\nCalculates (occupied sites)/(no. of neighbors)\n\n\"Occupied\" is defined as not equal to zero(T).\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html#Available-dynamics","page":"Dynamics","title":"Available dynamics","text":"","category":"section"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"Routines to evolve a given state for a number of timesteps.","category":"page"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"All routines take a state::TumorConfiguration as their first argument, and further parameters like mutation rate as keyword arguments.","category":"page"},{"location":"dynamics.html","page":"Dynamics","title":"Dynamics","text":"LatticeTumorDynamics.moran!\nLatticeTumorDynamics.eden_with_density!\nLatticeTumorDynamics.exponential!","category":"page"},{"location":"dynamics.html#GrowthDynamics.LatticeTumorDynamics.moran!","page":"Dynamics","title":"GrowthDynamics.LatticeTumorDynamics.moran!","text":"moran!(state::NoLattice{Int}; <keyword arguments>)\n\n(Extended) Moran dynamics on an unstructured population. Grow until carrying capacity is reach. After that individuals begin replacing each other.\n\nArguments\n\nT::Int: the number of steps to advance.\nfitness: function that assigns a fitness value to a genotype g::Int.\np_grow=1.0: Probability with which to actually proliferate. If no proliferation happens, mutation might still occur.\nmu: mutation rate.\nmu_type=[:poisson, :fixed]: Number of mutations is fixed, or Poisson-distributed.\ngenome_length=10^9: Length of the haploid genome.\nd: death rate.\nbaserate: progressing real time is measured in 1/baserate.\nprune_period: prune the phylogeny periodically after no. of steps.\nprune_on_exit: prune before leaving the simulation loop.\ncallback: function of state and time to be called at each iteration.   Used primarily for collecting observables during the run.\nabort: condition on state and time under which to end the run.\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html#GrowthDynamics.LatticeTumorDynamics.eden_with_density!","page":"Dynamics","title":"GrowthDynamics.LatticeTumorDynamics.eden_with_density!","text":"eden_with_density!(state::RealLattice{Int}; <keyword arguments>)\n\nMoran-like dynamics on an spatially structured population. Each step is either a death or (potential) birth and mutation event.\n\nIndividuals die at a rate d. Birthrate depends linearily on the number of neighbors.\n\nArguments\n\nT::Int: the number of steps to advance.\nfitness: function that assigns a fitness value to a genotype. Takes arguments (state, old genotype, new_genotype).\np_grow=1.0: Probability with which to actually proliferate. If no proliferation happens, mutation might still occur.\nmu=0.0: mutation rate.\nmu_type=[:poisson, :fixed]: Number of mutations is fixed, or Poisson-distributed.\ngenome_length=10^9: Length of the haploid genome.\nd=0.0: death rate. Zero halts the dynamics after carrying capacity is reached.\nbaserate=1.0: progressing real time is measured in 1/baserate.\nprune_period=0: prune the phylogeny periodically after no. of steps.\nprune_on_exit=true: prune before leaving the simulation loop.\ncallback: function of state and time to be called at each iteration.   Used primarily for collecting observables during the run.\nabort: condition on state and time under which to end the run.\n\n\n\n\n\n","category":"function"},{"location":"dynamics.html#GrowthDynamics.LatticeTumorDynamics.exponential!","page":"Dynamics","title":"GrowthDynamics.LatticeTumorDynamics.exponential!","text":"exponential!(state::NoLattice{Int}; <keyword arguments>)\n\nRun exponential growth on an unstructered population.\n\nArguments\n\nT::Int: the number of steps (generations) to advance.\nfitness: function that assigns a fitness value to a genotype g::Int.\nmu: mutation rate.\nbaserate: progressing real time is measured in 1/baserate.\nprune_period: prune the phylogeny periodically after no. of steps.\nprune_on_exit: prune before leaving the simulation loop.\ncallback: function of state and time to be called at each iteration.   Used primarily for collecting observables during the run.\nabort: condition on state and time under which to end the run.\n\n\n\n\n\n","category":"function"},{"location":"observables.html#Observables","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"observables.html","page":"Observables","title":"Observables","text":"List of built-in observables. They take a TumorConfiguration as the first and often only argument.","category":"page"},{"location":"observables.html","page":"Observables","title":"Observables","text":"Pages = [\"observables.md\"]","category":"page"},{"location":"observables.html","page":"Observables","title":"Observables","text":"Modules = [GrowthDynamics.TumorObservables]","category":"page"},{"location":"observables.html#GrowthDynamics.TumorObservables.allele_fractions","page":"Observables","title":"GrowthDynamics.TumorObservables.allele_fractions","text":"Dictionary of (SNP, freq).\n\n\n\n\n\n","category":"function"},{"location":"observables.html#GrowthDynamics.TumorObservables.allele_size","page":"Observables","title":"GrowthDynamics.TumorObservables.allele_size","text":"Dictionary (SNP, population count)\n\n\n\n\n\n","category":"function"},{"location":"observables.html#GrowthDynamics.TumorObservables.allele_spectrum-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration}","page":"Observables","title":"GrowthDynamics.TumorObservables.allele_spectrum","text":"allele_spectrum(state;[ threshold=0.0, read_depth=total_population_size(state)])\n\nReturn a DataFrame with count, frequency of every polymorphism. Additionally sample from the population.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.common_snps-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration}","page":"Observables","title":"GrowthDynamics.TumorObservables.common_snps","text":"common_snps(::TumorConfiguration; filterdead=true)\n\nList polymorphisms that are common to all genotypes.\n\nOptional arguments:\n\nfilterdead=true: exclude unpopulated genotypes?\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.explode_into_shells-Union{Tuple{T}, Tuple{Vector{T}, Any, Any}} where T<:(GeometryBasics.Pointf)","page":"Observables","title":"GrowthDynamics.TumorObservables.explode_into_shells","text":"explode_into_shells(v, o, a; a0=)\n\nTake a vector of cartesian coordinates v, center them around the midpoint o, and return a dictionary radius=>coordinates where a0<= radius <= max(||v||) in increments of a. \n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.living_ancestor-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration, Any}","page":"Observables","title":"GrowthDynamics.TumorObservables.living_ancestor","text":"Earliest living ancestor.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.mean_pairwise-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration}","page":"Observables","title":"GrowthDynamics.TumorObservables.mean_pairwise","text":"Diversity (mean pairwise difference of mutations) of a population.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.mrca-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration, Integer, Integer}","page":"Observables","title":"GrowthDynamics.TumorObservables.mrca","text":"Return index of the most recent common ancestor between (i,j) in a phylogeny.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.mrca-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration}","page":"Observables","title":"GrowthDynamics.TumorObservables.mrca","text":"Return index of the most recent common ancestor in a phylogeny.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.npolymorphisms-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration}","page":"Observables","title":"GrowthDynamics.TumorObservables.npolymorphisms","text":"npolymorphisms(S::TumorConfiguration)\n\nNumber of polymrphisms\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.pairwise-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration, Any, Any}","page":"Observables","title":"GrowthDynamics.TumorObservables.pairwise","text":"pairwise(S::TumorConfiguration, i, j)\n\nNumber of pairwise genomic differences between genotype indices i,j.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.pairwise-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration}","page":"Observables","title":"GrowthDynamics.TumorObservables.pairwise","text":"pairwise(S::TumorConfiguration)\n\nMatrix of pairwise differences.   filterdead: Do not include extinct genotypes.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.polymorphisms-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration}","page":"Observables","title":"GrowthDynamics.TumorObservables.polymorphisms","text":"polymorphisms(S::TumorConfiguration)\n\nVector of polymorphisms (segregating sites).\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.popsize_on_shells-Union{Tuple{T}, Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration{T, <:GrowthDynamics.Lattices.RealLattice}, Any}} where T","page":"Observables","title":"GrowthDynamics.TumorObservables.popsize_on_shells","text":"popsize_on_shells(T, outer, [o=midpoint(T.lattice)])\n\nCreates a dictionary genotype => trajectory where trajectory is a vector of population size. trajectory[r] is the the population size on a L2-norm shell of radius r around o.\n\nr ranges between 1..outer in increments of a (defaults to the lattice spacing).\n\nSet deleteone/zero=false to keep the wildtype/count empty sites.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.population_size-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration, Any}","page":"Observables","title":"GrowthDynamics.TumorObservables.population_size","text":"Dictionary (genotype, population size)\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.positions-Union{Tuple{N}, Tuple{T}, Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration{T, <:GrowthDynamics.Lattices.AbstractLattice{T, N}}, Any}} where {T, N}","page":"Observables","title":"GrowthDynamics.TumorObservables.positions","text":"positions(state, g)\n\nReturns coordinates of cells of genotype g.\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.sampled_allele_fractions","page":"Observables","title":"GrowthDynamics.TumorObservables.sampled_allele_fractions","text":"sampled_allele_fractions(S::TumorConfiguration[, t=0, samples=length(S.meta.npops)])\n\nRandomly sample genotypes(!) and calculate frequencies of contained SNPs. Return a dictionary (SNP, freq).\n\n\n\n\n\n","category":"function"},{"location":"observables.html#GrowthDynamics.TumorObservables.tajimasd-Tuple{Any, Any, Any}","page":"Observables","title":"GrowthDynamics.TumorObservables.tajimasd","text":"See https://en.wikipedia.org/wiki/Tajima%27s_D\n\n\n\n\n\n","category":"method"},{"location":"observables.html#GrowthDynamics.TumorObservables.total_population_size-Tuple{GrowthDynamics.TumorConfigurations.TumorConfiguration}","page":"Observables","title":"GrowthDynamics.TumorObservables.total_population_size","text":"Total population size. Duh.\n\n\n\n\n\n","category":"method"},{"location":"phylogenies.html#Phylogenies","page":"Phylogenies","title":"Phylogenies","text":"","category":"section"},{"location":"phylogenies.html","page":"Phylogenies","title":"Phylogenies","text":"A state::TumorConfiguration has a phylogenetic tree and metadata about the genotypes attached.   Any time evolution routine should take care of maintaining this tree and metadata.","category":"page"},{"location":"phylogenies.html","page":"Phylogenies","title":"Phylogenies","text":"The vertices v are always numbered from 1 and correspond to the genotype meta[v]. Use index(@ref) to find the id of a genotype.\nInserting a new genotype into the population via push!(::TumorConfiguration, newgenotype) will add a vertex to the phylogeny, but won't create an edge that connects it to the tree.","category":"page"},{"location":"phylogenies.html","page":"Phylogenies","title":"Phylogenies","text":"warning: Warning\nUse add_edge!(state, newgenotype, parent) (preferred) or add_edge!(state.phylogeny, newgenotype_id, parent_id) to connect the new genotype to the phylogeny.","category":"page"},{"location":"phylogenies.html","page":"Phylogenies","title":"Phylogenies","text":"    Modules = [GrowthDynamics.Phylogenies]","category":"page"},{"location":"phylogenies.html#GrowthDynamics.Phylogenies.add_snps!-Tuple{Vector, Any}","page":"Phylogenies","title":"GrowthDynamics.Phylogenies.add_snps!","text":"Take a vector of SNPS and add new ones, or replace them. Typically called from dynamics during a mutation event.\n\nμ: genome wide rate (Poisson) / count (uniform)\nL=10^9: length of the genome\nallow_multiple=false: Allow for a site to mutate more than once.\nkind=:poisson Either :poisson or :fixed\nreplace=false Replace existing SNPs.\n\n\n\n\n\n","category":"method"},{"location":"phylogenies.html#GrowthDynamics.Phylogenies.df_traversal!-Tuple{Vector{Int64}, Graphs.SimpleGraphs.SimpleDiGraph}","page":"Phylogenies","title":"GrowthDynamics.Phylogenies.df_traversal!","text":"See also df_traversal\n\n\n\n\n\n","category":"method"},{"location":"phylogenies.html#GrowthDynamics.Phylogenies.df_traversal-Tuple{Graphs.SimpleGraphs.SimpleDiGraph}","page":"Phylogenies","title":"GrowthDynamics.Phylogenies.df_traversal","text":"df_traversal(G::SimpleDiGraph; root=1)\n\nTraverse a phylogenetic tree depth first, starting at vertex root which defaults to 1.\n\nReturn a vector of vertices.\n\n\n\n\n\n","category":"method"},{"location":"phylogenies.html#GrowthDynamics.Phylogenies.has_children-Tuple{Any, Any}","page":"Phylogenies","title":"GrowthDynamics.Phylogenies.has_children","text":"Does a genotype have any children?\n\n\n\n\n\n","category":"method"},{"location":"phylogenies.html#GrowthDynamics.Phylogenies.sample_ztp-Tuple{Float64}","page":"Phylogenies","title":"GrowthDynamics.Phylogenies.sample_ztp","text":"sample_ztp(lambda)\n\nReturn one sample of a zero-truncated Poisson distribution with rate λ.\n\nSee \n\nNote: Should be in Distributions.jl.\n\n\n\n\n\n","category":"method"},{"location":"states.html#States","page":"States","title":"States","text":"","category":"section"},{"location":"states.html","page":"States","title":"States","text":"A state is a collection of","category":"page"},{"location":"states.html","page":"States","title":"States","text":"either a lattice<:RealLattice if the model is spatial (see lattices), or a dummy placeholder NoLattice if it is not.\na phylogenetic tree, which is a directed graph where the root(s) are the wildtype(s).\nmeta data about the population and its genetics. See Meta Data.\nthe time the state has been evolved for by invoking dynamics on it.","category":"page"},{"location":"states.html","page":"States","title":"States","text":"States are of type TumorConfiguration.","category":"page"},{"location":"states.html","page":"States","title":"States","text":"    CurrentModule = GrowthDynamics.TumorConfigurations","category":"page"},{"location":"states.html","page":"States","title":"States","text":"    TumorConfiguration","category":"page"},{"location":"states.html#GrowthDynamics.TumorConfigurations.TumorConfiguration","page":"States","title":"GrowthDynamics.TumorConfigurations.TumorConfiguration","text":"TumorConfiguration(lattice, [phylogeny])\n\nWraps an existing lattice in a TumorConfiguration. Calculates meta.npops automatically.\n\nIf phylogeny is not given, it defaults to an empty graph.\n\n\n\n\n\n","category":"type"},{"location":"states.html","page":"States","title":"States","text":"It is normally not required to manipulate meta data, phylogeny or lattice directly. Convenient methods to manipulate state are provided.","category":"page"},{"location":"states.html","page":"States","title":"States","text":"using Graphs\nusing GrowthDynamics\nusing GrowthDynamics.TumorConfigurations\nusing GrowthDynamics.Lattices","category":"page"},{"location":"states.html","page":"States","title":"States","text":"    state, _ = uniform(CubicLattice, 32; g=0)\n\n    # fails because the new genotype is yet unknown\n    state[16,16,16] = 1\n\n    # make it known first\n    push!(state, 1)\n    state[16,16,16] = 1;\n\n    state.meta\n\n    state[15:17,15:17,15:17]\n\n    push!(state, 2)\n    state[1:size(state,1), 1, 1] .= 2;\n\n    state.meta","category":"page"},{"location":"states.html#Convenience-constructors","page":"States","title":"Convenience constructors","text":"","category":"section"},{"location":"states.html","page":"States","title":"States","text":"Some convenience methods for common geometries are provided","category":"page"},{"location":"states.html","page":"States","title":"States","text":"uniform\nspheref\nspherer\nsingle_center\nhalf_space\nsphere_with_single_mutant_on_outer_shell","category":"page"},{"location":"states.html#GrowthDynamics.TumorConfigurations.uniform","page":"States","title":"GrowthDynamics.TumorConfigurations.uniform","text":"uniform(::Type{T<:RealLattice}, L; g=0, a=1.0)\n\nReturn a configuration on a lattice of type T with linear extension L, filled with genotype g.\n\nExample\n\njulia> uniform(HexagonalLattice, 128; g=1)\n(HexagonalLattice{Int64, Matrix{Int64}}\n1\tgenotypes\n16641\tpopulation, nothing)\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.TumorConfigurations.spheref","page":"States","title":"GrowthDynamics.TumorConfigurations.spheref","text":"spheref(::Type{T}, L::Int; r = 0, g1=0, g2=1) where LT<:Lattices.RealLattice\n\nFill lattice of type T (e.g CubicLattice) with genotype g1 and put a (L2-)sphere with genotype g2 that occupies approx. a fraction f of the lattice at the center.\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.TumorConfigurations.spherer","page":"States","title":"GrowthDynamics.TumorConfigurations.spherer","text":"spherer(::Type{T}, L::Int; r = 0, g1=0, g2=1) where LT<:Lattices.RealLattice\n\nFill lattice of type T (e.g CubicLattice) with genotype g1 and put a (L2-)sphere of approx. radius r with genotype g2 at the center.\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.TumorConfigurations.single_center","page":"States","title":"GrowthDynamics.TumorConfigurations.single_center","text":"single_center(::Type{T<:RealLattice}, L; g1=1, g2=2)\n\nPut a single cell of genotype g2 at the midpoint of a lattice filled with g1.\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.TumorConfigurations.half_space","page":"States","title":"GrowthDynamics.TumorConfigurations.half_space","text":"half_space(::Type{T<:RealLattice}, L; g1=1, g2=2)\n\nInstantiates a population of genotype g1 on a lattice of type T.  Fills the last dimension with g2 up to fraction f\n\nExample\n\njulia> using GrowthDynamics.TumorConfigurations\n\njulia> state = half_space(CubicLattice, 32, f=1/4, g1=1, g2=2)[1]\nCubicLattice{Int64, Array{Int64, 3}}\n2\tgenotypes\n35937\tpopulation\n\njulia> state.meta\n2-element MetaData{Int64}:\n (genotype = 1, npop = 27225, fitness = 1.0, snps = nothing, age = (0, 0.0))\n (genotype = 2, npop = 8712, fitness = 1.0, snps = nothing, age = (0, 0.0))\n\n\n\n\n\n","category":"function"},{"location":"states.html#GrowthDynamics.TumorConfigurations.sphere_with_single_mutant_on_outer_shell","page":"States","title":"GrowthDynamics.TumorConfigurations.sphere_with_single_mutant_on_outer_shell","text":"sphere_with_single_mutant_on_outer_shell(::Type{<:RealLattice}, L::Int; r, s=1.0)\n\nFill a ball of radius r with genotype 1. Place a single cell of genotype 2 on the outermost shell at random.\n\n\n\n\n\n","category":"function"},{"location":"index.html#GrowthDynamics.jl","page":"Overview","title":"GrowthDynamics.jl","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"This package implements various models of growing and evolving populations, both with and without spatial structure.","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"A number of useful observables are defined.","category":"page"},{"location":"index.html#Quick-Start","page":"Overview","title":"Quick Start","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"Let's give an overview of the components acting together.","category":"page"},{"location":"index.html#States","page":"Overview","title":"States","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"A state is a structure comprised of a lattice (see Lattices), each entry representing a member of the population, its value representing its genotype, and various metadata. In unstructered populations the lattice is simply a dummy.","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"The metadata store information about the current state of the various genotypes, like number of individuals present, their fitness, and so on. Furthermore a phylogenetic tree is recorded during simulation, enabling access to observables like most-recent common ancestors, or tracking of lineages.","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"import GrowthDynamics.TumorConfigurations: spheref\nimport GrowthDynamics.Lattices: HexagonalLattice\nusing GrowthDynamics.LatticeTumorDynamics\nusing GrowthDynamics.TumorObservables\nimport DataFrames: first # hide\n\nstate, _ = spheref(HexagonalLattice, 128, f=1/10, g1=0, g2=1)","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"This prepares a state on a two-dimensional hexagonal lattice of size 128^2 that is unoccupied (genotype 0 is per definition understood as unoccupied.) except for a centered disk of genotype 1 that comprises ~1/10 of the total population.","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"Every mutation event introduces a new genotype. They are by default labeled consecutively by integers, but custom labels are possible.","category":"page"},{"location":"index.html#Dynamics","page":"Overview","title":"Dynamics","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"Now evolve the population.","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"eden_with_density!(state;\n  T=128^2, # timesteps\n  mu=1e0,  # mutation rate per genome (not site!)\n  d=1/100, # death rate\n  fitness=(s,g_old,g_new)->1.0 + 0.1*randn() # function to assign fitness to new genotypes\n)\n\nshow(state)","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"We can plot (done using Makie.jl) mathe distribution of fitness values to check if it conforms to expectation","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"using CairoMakie #hide\nhist(state.meta[:, :fitness], axis=(xlabel=\"Fitness\", ylabel=\"Frequency\")) #hide","category":"page"},{"location":"index.html#Observables","page":"Overview","title":"Observables","text":"","category":"section"},{"location":"index.html","page":"Overview","title":"Overview","text":"# number of polymorphisms and diversity\nnpolymorphisms(state), mean_pairwise(state)","category":"page"},{"location":"index.html","page":"Overview","title":"Overview","text":"# alleles with frequency larger 0.01\nfirst(sort(allele_spectrum(state, threshold=0.01), :fpop), 6)","category":"page"},{"location":"metadata.html#Meta-Data","page":"Meta Data","title":"Meta Data","text":"","category":"section"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"CurrentModule = GrowthDynamics.TumorConfigurations","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"Every TumorConfiguration has MetaData attached. They contain for every genotype","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"A population count. While in principle redundant, it is significantly cheaper than enumerating the lattice.\nA fitness value\nTODO: A death rate\nMutations: Either nothing, or a vector of Int if mutations are present.\nA timestamp when the genotype entered the population.","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"Additionally, meta.misc is a dictionary for storing arbitrary user-defined key-value pairs.","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"Convenient getter and setter routines are provided. Let's demonstrate with an example similar to the one from the Quick Start section, but label genotypes with strings of fixed length (from InlineStrings.jl)","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"import Random\nRandom.seed!(1234)\n\nimport GrowthDynamics.TumorConfigurations: spheref\nimport GrowthDynamics.Lattices: HexagonalLattice\nusing GrowthDynamics.LatticeTumorDynamics\nusing GrowthDynamics.TumorObservables\nimport DataFrames: first # hide","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"using InlineStrings\nimport Base: zero\nzero(::Type{String7}) = String7(\"00-00\")\n\nstate, _ = spheref(HexagonalLattice, 128, f=1/10, g1=String7(\"00-00\"), g2=String7(\"00-AA\"))\n\neden_with_density!(state;\n  label=(state,g)->String7( join(rand('0':'9',2))*\"-\"*join(rand('A':'Z',2)) ),\n  T=1024, # timesteps\n  mu=1e0,  # mutation rate per genome (not site!)\n  d=1/100, # death rate\n  fitness=(s,g_old,g_new)->1.0 + 0.1*randn() # function to assign fitness to new genotypes\n)","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"state.meta","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"We can query according to index","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"state.meta[2, :genotype]","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"state.meta[5:10, :npop]","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"or genotype","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"state.meta[g=\"46-YQ\"]","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"state.meta[g=\"46-YQ\", :fitness] = 1.1","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"note: Note\nIn places where performance is paramount, getter and setter should be called like state.meta[2, Val(:genotype)] to circumvent dynamic dispatch.Alternatively, getgenotype(state, id), setgenotype!(state, id), etc. are provided.","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"Because MetaData implements Julia's array interface, iterating is supported, and because each MetaDatum is a NamedTuple, we can for example convert to a DataFrame","category":"page"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"using DataFrames\n\nfilter(v->v.npop>10, state.meta) |> DataFrame","category":"page"},{"location":"metadata.html#API","page":"Meta Data","title":"API","text":"","category":"section"},{"location":"metadata.html","page":"Meta Data","title":"Meta Data","text":"MetaData\nMetaDatum\nindex(::MetaData{T}, ::T) where {T}\nindex!","category":"page"},{"location":"metadata.html#GrowthDynamics.TumorConfigurations.MetaData","page":"Meta Data","title":"GrowthDynamics.TumorConfigurations.MetaData","text":"MetaData{T}\n\nIndexable structure to store information about a population.\n\nAccess\n\nUse meta[id, :field] or meta[g=G, :field] to access and set information for genotype G, or the genotype with id id respectively.\n\nid is also the number of the vertex in the phylogeny corresponding to a given genotype.\n\n:field is one of\n\n:npop - population size\n:fitness - fitness value\n:genotype - genotype corresponding to a given id\n:snps: - vector of integers representing mutations a genotype carries.  nothing if no mutations are present.\n:age: tuple of (timestep, realtime) of when the genotype was first instantiated.\n\nUseful for putting lengths on the branches of a phylogeny.\n\nAdditionally, a global field meta.misc::Dict{Any,Any} exists to store arbitrary, user-defined information.\n\nSee also MetaDatum\n\n\n\n\n\n","category":"type"},{"location":"metadata.html#GrowthDynamics.TumorConfigurations.MetaDatum","page":"Meta Data","title":"GrowthDynamics.TumorConfigurations.MetaDatum","text":"MetaDatum{T,S}\n\nNamedTuple to store information about a single genotype of type T that carries mutations of type S (default Int).\n\n\n\n\n\n","category":"type"},{"location":"metadata.html#GrowthDynamics.TumorConfigurations.index!","page":"Meta Data","title":"GrowthDynamics.TumorConfigurations.index!","text":"index!(::MetaData)\n\nReindex the metadata.\n\n\n\n\n\n","category":"function"}]
}
